// SPDX-License-Identifier: MIT
pragma solidity ^0.8.24;

import {FHE, euint64, externalEuint64} from "@fhevm/solidity/lib/FHE.sol";
import {ZamaEthereumConfig} from "@fhevm/solidity/config/ZamaConfig.sol";

/// @title ZamaFundraiser
/// @notice Crowdfunding contract that records encrypted contribution amounts using Zama FHE
contract ZamaFundraiser is ZamaEthereumConfig {
    string public campaignName;
    uint256 public fundraisingGoal;
    uint256 public endTime;
    address public immutable organizer;
    uint256 public totalRaised;
    bool public isClosed;

    euint64 private encryptedTotalRaised;
    mapping(address => euint64) private encryptedContributions;
    mapping(address => uint256) private lastContributionAt;
    mapping(address => uint256) private clearContributions;

    bool private locked;

    event CampaignUpdated(string name, uint256 goal, uint256 endTime);
    event ContributionReceived(address indexed contributor, uint256 amountWei, euint64 encryptedBalance);
    event CampaignClosed(address indexed organizer, uint256 amountWithdrawn);

    modifier onlyOrganizer() {
        require(msg.sender == organizer, "Only organizer");
        _;
    }

    modifier campaignActive() {
        require(!isClosed, "Campaign closed");
        require(block.timestamp < endTime, "Campaign ended");
        _;
    }

    modifier nonReentrant() {
        require(!locked, "ReentrancyGuard: reentrant call");
        locked = true;
        _;
        locked = false;
    }

    constructor(string memory name_, uint256 goal_, uint256 endTime_) {
        require(bytes(name_).length > 0, "Name required");
        require(goal_ > 0, "Goal required");
        require(endTime_ > block.timestamp, "End time must be in future");

        campaignName = name_;
        fundraisingGoal = goal_;
        endTime = endTime_;
        organizer = msg.sender;
        encryptedTotalRaised = FHE.asEuint64(0);
        FHE.allowThis(encryptedTotalRaised);
        FHE.allow(encryptedTotalRaised, msg.sender);
    }

    /// @notice Update campaign metadata while it is active
    /// @param name_ New campaign name
    /// @param goal_ New goal amount in wei
    /// @param endTime_ New unix timestamp when the campaign ends
    function configureCampaign(string calldata name_, uint256 goal_, uint256 endTime_) external onlyOrganizer {
        require(!isClosed, "Campaign closed");
        require(bytes(name_).length > 0, "Name required");
        require(goal_ > 0, "Goal required");
        require(endTime_ > block.timestamp, "End time must be in future");

        campaignName = name_;
        fundraisingGoal = goal_;
        endTime = endTime_;

        emit CampaignUpdated(name_, goal_, endTime_);
    }

    /// @notice Contribute ETH with the encrypted amount recorded on-chain
    /// @param encryptedAmount Encrypted contribution amount (wei)
    /// @param proof Proof generated by the relayer SDK for encrypted input
    function contribute(externalEuint64 encryptedAmount, bytes calldata proof)
        external
        payable
        campaignActive
        nonReentrant
    {
        require(msg.value > 0, "Contribution required");
        require(msg.value <= type(uint64).max, "Contribution too large");

        euint64 providedAmount = FHE.fromExternal(encryptedAmount, proof);

        euint64 contributorCipher = encryptedContributions[msg.sender];
        euint64 updatedContributor = FHE.add(contributorCipher, providedAmount);
        encryptedContributions[msg.sender] = updatedContributor;
        FHE.allowThis(updatedContributor);
        FHE.allow(updatedContributor, msg.sender);
        FHE.allow(updatedContributor, organizer);

        encryptedTotalRaised = FHE.add(encryptedTotalRaised, providedAmount);
        FHE.allowThis(encryptedTotalRaised);
        FHE.allow(encryptedTotalRaised, organizer);

        lastContributionAt[msg.sender] = block.timestamp;
        clearContributions[msg.sender] += msg.value;
        totalRaised += msg.value;

        emit ContributionReceived(msg.sender, msg.value, updatedContributor);
    }

    /// @notice Close the campaign and withdraw all ETH to the organizer
    function closeCampaign() external onlyOrganizer nonReentrant {
        require(!isClosed, "Campaign closed");
        isClosed = true;

        uint256 balance = address(this).balance;
        emit CampaignClosed(organizer, balance);

        (bool success, ) = organizer.call{value: balance}("");
        require(success, "Withdraw failed");
    }

    /// @notice Returns public campaign details
    function getCampaignDetails()
        external
        view
        returns (string memory name_, uint256 goal_, uint256 endTime_, bool closed, uint256 raised, address owner)
    {
        return (campaignName, fundraisingGoal, endTime, isClosed, totalRaised, organizer);
    }

    /// @notice Returns encrypted stats for a specific contributor
    /// @param contributor Address to inspect
    function getContribution(address contributor)
        external
        view
        returns (euint64 encryptedAmount, uint256 clearAmount, uint256 lastAt)
    {
        return (encryptedContributions[contributor], clearContributions[contributor], lastContributionAt[contributor]);
    }

    /// @notice Returns encrypted total raised amount
    function getEncryptedTotalRaised() external view returns (euint64) {
        return encryptedTotalRaised;
    }
}
